import android.os.Bundle
import android.util.DisplayMetrics
import android.util.Log
import android.util.Size
import android.widget.TextView
import androidx.annotation.OptIn
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import androidx.camera.core.Preview
import androidx.camera.core.resolutionselector.ResolutionSelector
import androidx.camera.core.resolutionselector.ResolutionStrategy
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors


open class ReaderQR : AppCompatActivity() {

    var used: Boolean = false
    var nrPck = 0

    //unintialized UI elements
    private lateinit var previewView: PreviewView
    private lateinit var resultTextView: TextView
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var barcodeScanner: BarcodeScanner

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_reader_qr)


        previewView = findViewById(R.id.previewView)
        resultTextView = findViewById(R.id.resultTextView)
        cameraExecutor = Executors.newSingleThreadExecutor()

        //barcodescanner to process the image
        barcodeScanner = BarcodeScanning.getClient()

        //req camera perm

        /* val requestPermissionLauncher = registerForActivityResult(
            ActivityResultContracts.RequestPermission())
        {
            isGranted: Boolean ->
            if(isGranted) {
                startCamera()
            } else {
                resultTextView.text = "Camera Permission is required"
            }
        }
        requestPermissionLauncher.launch(android.Manifest.permission.CAMERA) */
        startCamera()
    }

    fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this);

        val displayMetrics = DisplayMetrics()

        windowManager.defaultDisplay.getMetrics(displayMetrics)

        val width = displayMetrics.widthPixels

        val height = displayMetrics.heightPixels

        val screenSize = Size(width, height)
        //if this size for the screen is not available then use no other resolution strategy => FALLBACK_RULE_NONE
        val resolutionSelector = ResolutionSelector.Builder().setResolutionStrategy(
            ResolutionStrategy(screenSize, ResolutionStrategy.FALLBACK_RULE_CLOSEST_HIGHER_THEN_LOWER)
            ).build()

        cameraProviderFuture.addListener({
            val cameraProvider = cameraProviderFuture.get()

            //to allow live camera feedback to the screen
            //attach the preview of the camera to the UI preview = > automatic detection of qr code
            val preview = Preview.Builder().setResolutionSelector(resolutionSelector)
                .build()
                .also {
                    it.setSurfaceProvider { previewView.surfaceProvider }
                }
            val imageAnalyzer = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor) { imageProxy ->
                        //process image result
                        processImageProxy(imageProxy)
                    }
                }

            //select default camera - > back camera
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            //link image to the preview to the image-analyzer(process frames to analyze simultaneously)
            cameraProvider.bindToLifecycle(this as LifecycleOwner,
                cameraSelector, preview, imageAnalyzer)

        }, ContextCompat.getMainExecutor(this))
    }

    @OptIn(ExperimentalGetImage::class)
    private fun processImageProxy(imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if(mediaImage != null) {
            //image is converted into an input image
            //rotationDegrees used for accurate scan - image is rotated correctly
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            //process the image
            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        //handle barcode
                        Log.d("Barcode Scanner:", barcode.toString())
                        println("ce a citit din qr  - > " + barcode.toString())
                    }
                }
                .addOnFailureListener {
                    resultTextView.text = "Failed to scan qr code"
                }
                .addOnCompleteListener() {
                    //clean up memory and allow nxt frame to pe processed
                    imageProxy.close()
                }
        }

    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }


}